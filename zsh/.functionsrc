#!/usr/bin/env bash

####################
# Temporary functions
####################

# Search a theme file for color references that aren't included in the Nord palette
function nord() {
	ack "color" "$1" | ack --invert-match '2E3440|3B4252|434C5E|4C566A|D8DEE9|E5E9F0|ECEFF4k|8FBCBB|88C0D0|81A1C1|5E81AC|BF616A|D08770|EBCB8B|A3BE8C|B48EAD'
}

####################
# Work functions
####################

# TODO Turn this into a Makefile target in the actual project
function poots() {
	(
		export AZURE_SUBSCRIPTION_ID="poots"

		wd validator
		ruler "make provision-kind" && \
		make provision-kind && \
		ruler "kustomize bootstrap-prod" && \
		kustomize build deploy/bootstrap-prod | envsubst | k apply -f - && \
		ruler "kustomize monitoring" && \
		kustomize build deploy/bases/monitoring/metrics-exporter | k apply -f - && \
		ruler "Deploy noop validator" && \
		kaf config/samples/test1.yaml -n validations
	)
}

function butts() {
	(
		wd validator
		cd deploy/bases/prometheus || return
		ruler "Point to local repository" && \
		kustomize edit set image exporter=localhost:5000/aks/prom-to-geneva:test
		ruler "kustomize build and apply" && \
		kustomize build . | k apply -f -
	)
}

# Get logs from the Validator manager
function validatorLogs() {
	MANAGER=$(k get po -n validator-crd-system | grep 'validator-crd-controller-manager' | awk '{print $1}')
	k logs -f -n validator-crd-system "$MANAGER" manager
}

# Test local Validator code by deploying to the Kind cluster and examining logs
function loopKind() {
	ruler "Redeploying"
	make redeploy-validator
	ruler "Sleeping"
	sleep 20
	ruler "Getting logs"
	validatorLogs
}

# Test local Validator code without deploying to the Kind cluster
function loopLocal() {
	ruler "Deleting manager"
	kdelr pod -n validator-crd-system validator-crd-controller-manager
	ruler "Running make run"
	make run
}

# Putting this here until I move it into aks-ci
function deployNanny() {
	ruler "Building Nanny"
	./aks-ci underlay-nanny-build
	ruler "Building Nanny Docker container"
	./aks-ci underlay-nanny-docker-build
	ruler "Pushing Nanny Docker container"
	./aks-ci underlay-nanny-docker-push
	ruler "Setting permissions on cluster"
	kubectl create clusterrolebinding permissive-binding --clusterrole=cluster-admin --user=admin --user=kubelet --group=system:serviceaccounts
	ruler "Deleting existing helm deployment"
	h del --purge underlay-nanny
	ruler "Purging namespace"
	kubectl delete ns infra
	ruler "Deploying to cluster"
	envsubst < docs/helm-deploy.sh | bash
	ruler "Sleeping for 30 seconds"
	sleep 30
	ruler "Getting logs"
	getNannyLogs
}

function getNannyLogs() {
	k logs -f -n infra "$(k get po -n infra | grep 'Running\|Completed\|CrashLoopBackOff' | awk '{print $1}')"
}

# This function mimics `eval $(aksiknife dev-setup)` but uses pass to circumvent the need for an AME card
azlogin() {
	AZURE_TENANT_ID=$(pass show "$1"/"$2"/azure-tenant-id)
	export AZURE_TENANT_ID
	AZURE_CLIENT_ID=$(pass show "$1"/"$2"/azure-client-id)
	export AZURE_CLIENT_ID
	AZURE_CLIENT_SECRET=$(pass show "$1"/"$2"/azure-client-secret)
	export AZURE_CLIENT_SECRET

	az login --tenant "$AZURE_TENANT_ID" --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET"
}

# Quickly cat or edit the latest #snippet doc (and auto commit the changes)
# Usage: `snippet` (edits current week's snippet)
#        `snippet -c` (`cat` out the contents of the current week's snippet for copypasta)
#        `snippet -l` (edit last week's snippet)
#        `snippet -lc` (`cat` last week's snippet for copypasta)
function snippet() {
	(
	# Get values from flags
	COPY_MODE=false
	LAST_WEEK=false
	while getopts "cl" opt; do
		case $opt in
			c) COPY_MODE=true ;;
			l) LAST_WEEK=true ;;
			*) echo "Usage: snippet -c -l" && return ;;
		esac
	done

	cd ~/projects/personal-retrospectives/snippets || return
	MONDAY="$(date -d "$(date -d "$(date -dfriday) - 4 days")" +%m-%d-%Y)"
	FRIDAY="$(date -dfriday +%m-%d-%Y)"
	CURRENT_SNIPPET="$MONDAY-to-$FRIDAY.md"
	LAST_MONDAY="$(date -d "$(date -dlast-friday) - 4 days" +%m-%d-%Y)"
	LAST_FRIDAY="$(date -dlast-friday +%m-%d-%Y)"
	LAST_WEEK_SNIPPET="$LAST_MONDAY-to-$LAST_FRIDAY.md"

	if [[ $COPY_MODE = true ]]
	then
		if [[ $LAST_WEEK = true ]]
		then
			cat "$LAST_WEEK_SNIPPET"
		else
			cat "$CURRENT_SNIPPET"
		fi
	else
		if [[ $LAST_WEEK = true ]]
		then
			nvim "$LAST_WEEK_SNIPPET"
		else
			if [[ -f "$CURRENT_SNIPPET" ]]
			then
				nvim "$CURRENT_SNIPPET"
			else
				# Create a new snippet file since there wasn't an existing one
				SHORT_MONDAY="$(date -d "$(date -d "$(date -dfriday) - 4 days")" +%m/%d)"
				SHORT_FRIDAY="$(date -dfriday +%m/%d)"
				NEW_SNIPPET="$MONDAY-to-$FRIDAY.md"
				echo -e "#snippet $SHORT_MONDAY - $SHORT_FRIDAY\n- [HIGHLIGHT] \n- " > "$NEW_SNIPPET"
				nvim "$NEW_SNIPPET"
			fi
		fi

		git add -A
		git commit -m "Automatic #snippet update"
		git push
	fi
	)
}

####################
# git functions
####################

# cd to the root of the current repository
function root() {
	cd "$(git rev-parse --show-toplevel)" || return
}

# Create a new GitHub repo and clone it
function gnew() {
	if [[ -z "$2" ]]
	then
		gh repo create "$1" --public
	else
		gh repo create "$1" --public --description "$2"
	fi

	gh repo clone "$1"
}

# Quickly make Git ignore a file's changes
function gu() {
	NO_ASSUME_UNCHANGED_MODE=false
	while getopts "n" opt; do
		case $opt in
			n) NO_ASSUME_UNCHANGED_MODE=true ;;
			*) echo "Usage: gu -n" && return ;;
		esac
	done


	if [[ -z "$1" ]]
	then
		# List files current marked as "assume unchanged"
		(
			root
			git ls-files -v | grep -e "^[hsmrck]"
		)
	else
		if [[ $NO_ASSUME_UNCHANGED_MODE = true ]]
		then
			git update-index --no-assume-unchanged "$2"
		else
			git update-index --assume-unchanged "$1"
		fi
	fi
}

# Compare the current branch to a supplied branch (or master if no branch is supplied) and view the diff (similar to creating a GitHub PR)
function gdpr() {
	if [[ -z "$1" ]]
	then
		git diff master..."$(git rev-parse --abbrev-ref HEAD)"
	else
		git diff "$1"..."$(git rev-parse --abbrev-ref HEAD)"
	fi
}

# Quickly merge the current branch with a supplied branch (or master if no branch is supplied)
function gm() {
	BRANCH=$(git rev-parse --abbrev-ref HEAD)

	if [[ -z "$1" ]]
	then
		git checkout master && git pull && git checkout "$BRANCH" && git merge master
	else
		git checkout "$1" && git pull && git checkout "$BRANCH" && git merge "$1"
	fi
}

# Checkout a PR by PR number (useful if someone created a PR from a fork)
# Note: 'git pr checkout $1' should work in place of this function but receives "x509: certificate signed by unknown authority" because of Walmart security settings
function gcpr() {
	git checkout master && git pull && git pull origin pull/"$1"/head:pr/"$1" && git checkout pr/"$1"
}

# Delete local git branches that are not present on the remote
function gclean() {
	git remote prune origin >/dev/null 2>&1

	MERGED_BRANCHES=$(git branch --merged master --no-color | cut -c 3- | grep -v '^[ *]*master$')
	ORPHAN_BRANCHES=$(grep gone <(git branch -v) | cut -d ' ' -f 3)
	BRANCHES_WITH_NO_REMOTE=$(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }')

	if [[ -n "$MERGED_BRANCHES" ]]; then
		ruler "Merged branches"
		echo "$MERGED_BRANCHES"
	fi

	if [[ -n "$ORPHAN_BRANCHES" ]]; then
		ruler "Orphan branches"
		echo "$ORPHAN_BRANCHES"
	fi

	if [[ -n "$BRANCHES_WITH_NO_REMOTE" ]]; then
		ruler "Branches with no remote"
		echo "$BRANCHES_WITH_NO_REMOTE"
	fi

	if [[ -z "$MERGED_BRANCHES" ]] && [[ -z "$ORPHAN_BRANCHES" ]] && [[ -z "$BRANCHES_WITH_NO_REMOTE" ]]
	then
		echo "Repo is already clean"
	else
		echo
		read -r "DELETE?Force delete the listed branches? [y/N] "
		if [ "$DELETE" = "y" ]; then
			[[ -n "$MERGED_BRANCHES" ]] && { echo "$MERGED_BRANCHES" | xargs git branch -D; }
			[[ -n "$ORPHAN_BRANCHES" ]] && { echo "$ORPHAN_BRANCHES" | xargs git branch -D; }
			[[ -n "$BRANCHES_WITH_NO_REMOTE" ]] && { echo "$BRANCHES_WITH_NO_REMOTE" | xargs git branch -D; }
		else
			echo "Aborted"
		fi
	fi
}

# Add all git changes with a commit message and push to remote
function g() {
	if [ -z "$1" ]
	then
		echo "No commit message supplied"
	else
		git add -A
		git commit -s -m "$1"
		git push -u
	fi
}

# Generate a .gitignore file using gitignore.io
function gitignore() {
	if [ -z "$1" ]
	then
		curl -L -s https://www.gitignore.io/api/linux,macos,windows
	else
		if [ "$1" = "list" ]
		then
			if [ -z "$2" ]
			then
				curl -L -s https://www.gitignore.io/api/list?format=lines
			else
				curl -L -s https://www.gitignore.io/api/list?format=lines | ack "$2"
			fi
		else
			curl -L -s https://www.gitignore.io/api/"$1"
		fi
	fi
}

# Find local git repositories that have unpushed commits or uncommitted files
function wip() {
	while IFS= read -r -d '' REPO
	do
		# Use a subshell to avoid having to cd out of the directory)
		(
		cd "$REPO" && cd ..

		if [[ -n $(git --no-pager diff HEAD) || -n $(git status --short) || -n $(git cherry -v 2>&1) || -n $(git --no-pager log --branches --not --remotes --no-walk --pretty=tformat:"%d%n") || -n $(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }') ]]
		then
			echo "$REPO"

			# Make newlines the only split character
			IFS=$'\n'

			for LINE in $(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }')
			do
				echo "  No remote: $LINE"
			done

			for LINE in $(git --no-pager log --branches --not --remotes --no-walk --pretty=tformat:"%d%n")
			do
				echo "  Unpushed/outdated: $LINE"
			done
		fi
		)
	done < <(find . -name .git -type d -prune -print0)
}

####################
# Docker functions
####################

# Kill all running containers
function drydock() {
	docker kill "$(docker ps -a -q)" 2>/dev/null || true
}

# Kill and remove all containers
function scuttle() {
	docker kill "$(docker ps -a -q)" 2>/dev/null || true
	docker rm "$(docker ps -a -q)" 2>/dev/null || true
}

# Remove everything Docker-related
function sink() {
	docker system prune -a --volumes
}

####################
# Ren'Py functions
####################

# Change underscores to spaces in filesname
function snake() {
	# shellcheck disable=SC2016
	zmv '*_*' '$f:gs/_/ '
}

# Resize images from the 1080p resolution on my iPad to the 720p resolution used in Ren'Py
function renimg() {
	mv "$1" "$1.bak"
	convert "$1.bak" -resize 66.666% "$1"
}

# Convert sound files to OGG
function rensfx() {
	# shellcheck disable=SC2001
	NEW_NAME=$(echo "$1" | sed 's/\..*$/\.ogg/g')
	ffmpeg -i "$1" -acodec libvorbis "$NEW_NAME"
}

# Print image dimensions
function imid() {
	identify -format "%wx%h" "$1"
}

####################
# General functions
####################

# Run nvim and open search if no arguments are passed
function v() {
	if [ $# -eq 0 ]; then
		nvim -c "Rg!"
	else
		nvim "$@"
	fi
}

function s() {
	nvim -c "Rg! $1"
}

# Fuzzy cd to selected directory
function cdf() {
	# DIR=$(find ${1:-.} -type d 2> /dev/null | fzf +m)
	DIR=$(find . -type d 2> /dev/null | fzf +m)
	print -z -- "cd $DIR"
}

# Fuzzy cd into the directory of the selected file
function cdff() {
	FILE=$(fzf +m -q "$1") && DIR=$(dirname "$FILE")
	print -z -- "cd $DIR"
}

# Quickly make a warp point with the name of the current directory
function wda() {
	CUR_DIR=$(basename "$(pwd)")
	# Remove leading periods
	CUR_DIR_STRIPPED="${CUR_DIR#.}"
	wd add "$CUR_DIR_STRIPPED" || return
	echo " + '$CUR_DIR_STRIPPED'"
}

# Echo output with surrounding whitespace and lines across the width of the screen for readability
function ruler() {
	printf '\n%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
	echo -e "$1"
	printf '%*s\n\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
}

# Attach to an existing tmux session
function tma() {
	tmux a -t "$1" -d
}

# Generate cellular automata wallpapers using gautomata
function cells() {
	if [ -z "$1" ]
	then
		echo "No iteration count supplied"
	else
		for ((i=0; i<$1; i++))
		do
			WIDTH=1920
			HEIGHT=800

			if [ -z "$2" ]
			then
				gautomata -w $WIDTH -h $HEIGHT -b -a random
			else
				gautomata -w $WIDTH -h $HEIGHT -b -a "$2"
			fi
		done

		echo "Scaling images"
		mogrify -scale 3840x1600+0+0 ./*.png
	fi
}

# Preview a file in the macOS Quick Look viewer
function q() {
	qlmanage -p "$@" >/dev/null 2>&1
}

# Copy the contents of a file to the clipboard
function copy() {
	pb < "$1"
}

# Run a LOVE project so you can see console output
function luv() {
	love "$(pwd)"
}

# Find disk usage by directory
function usage() {
	DIR="$1"

	if [[ $# -eq 0 || "$DIR" = "." ]]
	then
		DIR="$(pwd)"
	fi

	ruler "Total disk usage"
	df -h /
	ruler "Disk usage of $DIR"
	sudo du -cha --max-depth=1 "$DIR" | sort -rh | grep -E "M\s|G\s|K\s"
}

####################
# Kubernetes functions
####################

# Quickly find and type out a pod's name and namespace
# Usage: klf $(kgpf)
function kgpf() {
	POD_INFO="$(k get pods --all-namespaces | fzf)"
	NAMESPACE="$(echo "$POD_INFO" | awk '{print $1}')"
	POD="$(echo "$POD_INFO" | awk '{print $2}')"
	echo "-n $NAMESPACE $POD"
}

# Get all logs from the Kind cluster
function kla() {
	rm -rf /tmp/kind-logs
	kind export logs /tmp/kind-logs -q
	echo "Logs for kind cluster exported"
	cd /tmp/kind-logs || return
}

# Delete pod via regex
function kdelr() {
	# An array for non-flag arguments
	ARGS=()
	# Set default values for optional flags
	NAMESPACE="default"

	# Get values from flags
	while test $# -gt 0; do
		case "$1" in
			-n)
				shift
				NAMESPACE=$1
				shift
				;;
			*)
				ARGS+=("$1")
				shift
				;;
		esac
	done

	if [ ! ${#ARGS[@]} -eq 2 ]
	then
		echo "Usage: kdelr pod -n validator-crd-system validator-crd-controller-manager"
		return
	fi

	RESOURCE_TYPE="${ARGS[1]}"
	REGEX="${ARGS[2]}"

	kubectl get "$RESOURCE_TYPE" -n "$NAMESPACE" --no-headers=true | awk '/'"$REGEX"'/{print $1}'| xargs kubectl delete "$RESOURCE_TYPE" -n "$NAMESPACE"
}
