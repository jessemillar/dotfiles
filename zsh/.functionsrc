#!/usr/bin/env bash

####################
# k8s functions
####################

# Get all logs from the Kind cluster
function kla() {
	rm -rf /tmp/kind-logs
	kind export logs /tmp/kind-logs -q
	echo "Logs for kind cluster exported"
	cd /tmp/kind-logs || return
}

####################
# Work functions
####################

# Get logs from the Validator manager
function validatorLogs() {
	MANAGER=$(k get po -n validator-crd-system | grep 'validator-crd-controller-manager' | awk '{print $1}')
	k logs -f -n validator-crd-system "$MANAGER" manager
}

# Test local Validator code by deploying to the Kind cluster and examining logs
function loopKind() {
	ruler "Redeploying"
	make redeploy-validator
	ruler "Sleeping"
	sleep 20
	ruler "Getting logs"
	validatorLogs
}

# Test local Validator code without deploying to the Kind cluster
function loopLocal() {
	ruler "Deleting manager"
	kdelr pod -n validator-crd-system validator-crd-controller-manager
	ruler "Running make run"
	make run
}

# Putting this here until I move it into aks-ci
function deployNanny() {
	ruler "Building Nanny"
	./aks-ci underlay-nanny-build
	ruler "Building Nanny Docker container"
	./aks-ci underlay-nanny-docker-build
	ruler "Pushing Nanny Docker container"
	./aks-ci underlay-nanny-docker-push
	ruler "Setting permissions on cluster"
	kubectl create clusterrolebinding permissive-binding --clusterrole=cluster-admin --user=admin --user=kubelet --group=system:serviceaccounts
	ruler "Deleting existing helm deployment"
	h del --purge underlay-nanny
	ruler "Purging namespace"
	kubectl delete ns infra
	ruler "Deploying to cluster"
	envsubst < docs/helm-deploy.sh | bash
	ruler "Sleeping for 30 seconds"
	sleep 30
	ruler "Getting logs"
	getNannyLogs
}

function getNannyLogs() {
	k logs -f -n infra "$(k get po -n infra | grep 'Running\|Completed\|CrashLoopBackOff' | awk '{print $1}')"
}

# This function mimics `eval $(aksiknife dev-setup)` but uses pass to circumvent the need for an AME card
azlogin() {
	AZURE_TENANT_ID=$(pass show "$1"/"$2"/azure-tenant-id)
	export AZURE_TENANT_ID
	AZURE_CLIENT_ID=$(pass show "$1"/"$2"/azure-client-id)
	export AZURE_CLIENT_ID
	AZURE_CLIENT_SECRET=$(pass show "$1"/"$2"/azure-client-secret)
	export AZURE_CLIENT_SECRET

	az login --tenant "$AZURE_TENANT_ID" --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET"
}

# Quickly cat or edit the latest #snippet doc (and auto commit the changes)
function snippet() {
	(
	cd ~/projects/personal-retrospectives/snippets || return
	MONDAY="$(date -dlast-monday +%m-%d-%Y)"
	FRIDAY="$(date -d "$(date -d "$(date -dlast-monday) + 4 days")" +%m-%d-%Y)"
	CURRENT_SNIPPET=$(ls "$MONDAY"*)

	if [[ $1 = "-c" ]]
	then
		cat "$CURRENT_SNIPPET"
	else
		if [[ -z "$CURRENT_SNIPPET" ]]
		then
			nvim "$MONDAY-to-$FRIDAY.md"
		else
			nvim "$CURRENT_SNIPPET"
		fi

		git add -A
		git commit -m "Automatic #snippet update"
		git push
	fi
	)
}

####################
# git functions
####################

# cd to the root of the current repository
function root() {
	cd "$(git rev-parse --show-toplevel)" || return
}

# Compare the current branch to a supplied branch (or master if no branch is supplied) and view the diff (similar to creating a GitHub PR)
function gdpr() {
	if [[ -z "$1" ]]
	then
		git diff master..."$(git rev-parse --abbrev-ref HEAD)"
	else
		git diff "$1"..."$(git rev-parse --abbrev-ref HEAD)"
	fi
}

# Quickly merge the current branch with a supplied branch (or master if no branch is supplied)
function gm() {
	BRANCH=$(git rev-parse --abbrev-ref HEAD)

	if [[ -z "$1" ]]
	then
		git checkout master && git pull && git checkout "$BRANCH" && git merge master
	else
		git checkout "$1" && git pull && git checkout "$BRANCH" && git merge "$1"
	fi
}

# Checkout a PR by PR number (useful if someone created a PR from a fork)
# Note: 'git pr checkout $1' should work in place of this function but receives "x509: certificate signed by unknown authority" because of Walmart security settings
function gcpr() {
	git checkout master && git pull && git pull origin pull/"$1"/head:pr/"$1" && git checkout pr/"$1"
}

# Delete local git branches that are not present on the remote
function gclean() {
	git remote prune origin >/dev/null 2>&1

	MERGED_BRANCHES=$(git branch --merged master --no-color | cut -c 3- | grep -v '^[ *]*master$')
	ORPHAN_BRANCHES=$(grep gone <(git branch -v) | cut -d ' ' -f 3)
	BRANCHES_WITH_NO_REMOTE=$(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }')

	if [[ -n "$MERGED_BRANCHES" ]]; then
		ruler "Merged branches"
		echo "$MERGED_BRANCHES"
	fi

	if [[ -n "$ORPHAN_BRANCHES" ]]; then
		ruler "Orphan branches"
		echo "$ORPHAN_BRANCHES"
	fi

	if [[ -n "$BRANCHES_WITH_NO_REMOTE" ]]; then
		ruler "Branches with no remote"
		echo "$BRANCHES_WITH_NO_REMOTE"
	fi

	if [[ -z "$MERGED_BRANCHES" ]] && [[ -z "$ORPHAN_BRANCHES" ]] && [[ -z "$BRANCHES_WITH_NO_REMOTE" ]]
	then
		echo "Repo is already clean"
	else
		echo
		read -r "DELETE?Force delete the listed branches? [y/N] "
		if [ "$DELETE" = "y" ]; then
			[[ -n "$MERGED_BRANCHES" ]] && { echo "$MERGED_BRANCHES" | xargs git branch -D; }
			[[ -n "$ORPHAN_BRANCHES" ]] && { echo "$ORPHAN_BRANCHES" | xargs git branch -D; }
			[[ -n "$BRANCHES_WITH_NO_REMOTE" ]] && { echo "$BRANCHES_WITH_NO_REMOTE" | xargs git branch -D; }
		else
			echo "Aborted"
		fi
	fi
}

# Add all git changes with a commit message and push to remote
function g() {
	if [ -z "$1" ]
	then
		echo "No commit message supplied"
	else
		git add -A
		git commit -s -m "$1"
		git push -u
	fi
}

# Generate a .gitignore file using gitignore.io
function gi() {
	if [ -z "$1" ]
	then
		curl -L -s https://www.gitignore.io/api/linux,macos,windows
	else
		if [ "$1" = "list" ]
		then
			if [ -z "$2" ]
			then
				curl -L -s https://www.gitignore.io/api/list?format=lines
			else
				curl -L -s https://www.gitignore.io/api/list?format=lines | ack "$2"
			fi
		else
			curl -L -s https://www.gitignore.io/api/"$1"
		fi
	fi
}

# Find local git repositories that have unpushed commits or uncommitted files
function wip() {
	while IFS= read -r -d '' REPO
	do
		# Use a subshell to avoid having to cd out of the directory)
		(
		cd "$REPO" && cd ..

		if [[ -n $(git --no-pager diff HEAD) || -n $(git status --short) || -n $(git cherry -v 2>&1) || -n $(git --no-pager log --branches --not --remotes --no-walk --pretty=tformat:"%d%n") || -n $(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }') ]]
		then
			echo "$REPO"

			# Make newlines the only split character
			IFS=$'\n'

			for LINE in $(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }')
			do
				echo "  No remote: $LINE"
			done

			for LINE in $(git --no-pager log --branches --not --remotes --no-walk --pretty=tformat:"%d%n")
			do
				echo "  Unpushed/outdated: $LINE"
			done
		fi
		)
	done < <(find . -name .git -type d -prune -print0)
}

####################
# Docker functions
####################

# Kill all running containers
function drydock() {
	docker kill "$(docker ps -a -q)" 2>/dev/null || true
}

# Kill and remove all containers
function scuttle() {
	docker kill "$(docker ps -a -q)" 2>/dev/null || true
	docker rm "$(docker ps -a -q)" 2>/dev/null || true
}

# Remove everything Docker-related
function sink() {
	docker system prune -a --volumes
}

####################
# General functions
####################

# Quickly make a warp point with the name of the current directory
function wda() {
	CUR_DIR=$(basename "$(pwd)")
	# Remove leading periods
	CUR_DIR_STRIPPED="${CUR_DIR#.}"
	wd add "$CUR_DIR_STRIPPED" || return
	echo " + '$CUR_DIR_STRIPPED'"
}

# Echo output with surrounding whitespace and lines across the width of the screen for readability
function ruler() {
	printf '\n%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
	echo -e "$1"
	printf '%*s\n\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
}

# Fuzzy find a file and then open it in nvim
function vf() {
	FILES=$(fzf)
	if [[ ! $FILES ]]; then
		return
	fi

	nvim "$FILES"
}

# Attach to an existing tmux session
function tma() {
	tmux a -t "$1" -d
}

# Find an image file's dimensions
function imgsize() {
	magick identify "$1"
}

# Generate cellular automata wallpapers using gautomata
function cells() {
	if [ -z "$1" ]
	then
		echo "No iteration count supplied"
	else
		for ((i=0; i<$1; i++))
		do
			WIDTH=1920
			HEIGHT=800

			if [ -z "$2" ]
			then
				gautomata -w $WIDTH -h $HEIGHT -b -a random
			else
				gautomata -w $WIDTH -h $HEIGHT -b -a "$2"
			fi
		done

		echo "Scaling images"
		mogrify -scale 3840x1600+0+0 ./*.png
	fi
}

# Preview a file in the macOS Quick Look viewer
function q() {
	qlmanage -p "$@" >/dev/null 2>&1
}

# Copy the contents of a file to the clipboard
function copy() {
	pb < "$1"
}

# Run a LOVE project so you can see console output
function luv() {
	love "$(pwd)"
}

# Quickly search the current directory (and child directories) for files with filenames or contents that match the supplied search term
function search() {
	# F_FLAG denotes only searching filenames
	F_FLAG=false
	# ACK_FLAGS specifies flags passed to ack
	ACK_FLAGS=()
	# Get the search term passed as the last argument
	for last; do true; done
	SEARCH_WORD="$last"

	printUsage() {
		printf "Usage: search -f -w queryWord"
	}

	while getopts 'ifw' flag; do
		case "${flag}" in
			i) ACK_FLAGS+=(-i) ;;
			f) F_FLAG=true ;;
			w) ACK_FLAGS+=(-w) ;;
			*) printUsage && return ;;
		esac
	done

	ruler "Filenames"
	find . -name "*$SEARCH_WORD*" | ack "${ACK_FLAGS[@]}" --passthru "$SEARCH_WORD"

	ruler "File contents"
	if [ "$F_FLAG" = false ]
	then
		ack "${ACK_FLAGS[@]}" "$SEARCH_WORD"
	fi
}

# Find disk usage by directory
function usage() {
	DIR="$1"

	if [[ $# -eq 0 || "$DIR" = "." ]]
	then
		DIR="$(pwd)"
	fi

	ruler "Total disk usage"
	df -h /
	ruler "Disk usage of $DIR"
	sudo du -cha --max-depth=1 "$DIR" | sort -rh | grep -E "M\s|G\s|K\s"
}

####################
# Kubernetes functions
####################

# Delete pod via regex
function kdelr() {
	# An array for non-flag arguments
	ARGS=()
	# Set default values for optional flags
	NAMESPACE="default"

	# Get values from flags
	while test $# -gt 0; do
		case "$1" in
			-n)
				shift
				NAMESPACE=$1
				shift
				;;
			*)
				ARGS+=("$1")
				shift
				;;
		esac
	done

	if [ ! ${#ARGS[@]} -eq 2 ]
	then
		echo "Usage: kdelr pod -n validator-crd-system validator-crd-controller-manager"
		return
	fi

	RESOURCE_TYPE="${ARGS[1]}"
	REGEX="${ARGS[2]}"

	kubectl get "$RESOURCE_TYPE" -n "$NAMESPACE" --no-headers=true | awk '/'"$REGEX"'/{print $1}'| xargs kubectl delete "$RESOURCE_TYPE" -n "$NAMESPACE"
}
