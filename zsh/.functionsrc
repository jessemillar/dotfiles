#!/usr/bin/env bash

####################
# k8s functions
####################

function kla() {
	rm -rf /tmp/kind-logs
	kind export logs /tmp/kind-logs -q
	echo "Logs for kind cluster exported"
	cd /tmp/kind-logs || exit
}

####################
# Work functions
####################

# Putting this here until I move it into aks-ci
function deployNanny() {
	ruler "Building Nanny"
	./aks-ci underlay-nanny-build
	ruler "Building Nanny Docker container"
	./aks-ci underlay-nanny-docker-build
	ruler "Pushing Nanny Docker container"
	./aks-ci underlay-nanny-docker-push
	ruler "Setting permissions on cluster"
	kubectl create clusterrolebinding permissive-binding --clusterrole=cluster-admin --user=admin --user=kubelet --group=system:serviceaccounts
	ruler "Deleting existing helm deployment"
	h del --purge underlay-nanny
	ruler "Purging namespace"
	kubectl delete ns infra
	ruler "Deploying to cluster"
	cat docs/helm-deploy.sh | envsubst | bash
	ruler "Sleeping for 30 seconds"
	sleep 30
	ruler "Getting logs"
	getNannyLogs
}

function getNannyLogs() {
	k logs -f -n infra $(k get po -n infra | grep 'Running\|Completed\|CrashLoopBackOff' | awk '{print $1}')
}

# This function mimics `eval $(aksiknife dev-setup)` but uses pass to circumvent the need for an AME card
azlogin() {
	AZURE_TENANT_ID=$(pass show "$1"/"$2"/azure-tenant-id)
	export AZURE_TENANT_ID
	AZURE_CLIENT_ID=$(pass show "$1"/"$2"/azure-client-id)
	export AZURE_CLIENT_ID
	AZURE_CLIENT_SECRET=$(pass show "$1"/"$2"/azure-client-secret)
	export AZURE_CLIENT_SECRET

	az login --tenant "$AZURE_TENANT_ID" --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET"
}

####################
# git functions
####################

# Compare the current branch to a supplied branch (or master if no branch is supplied) and view the diff (similar to creating a GitHub PR)
function gdpr() {
	if [[ -z "$1" ]]
	then
		git diff master..."$(git rev-parse --abbrev-ref HEAD)"
	else
		git diff "$1"..."$(git rev-parse --abbrev-ref HEAD)"
	fi
}

# Quickly merge the current branch with a supplied branch (or master if no branch is supplied)
function gm() {
	BRANCH=$(git rev-parse --abbrev-ref HEAD)

	if [[ -z "$1" ]]
	then
		git checkout master && git pull && git checkout "$BRANCH" && git merge master
	else
		git checkout "$1" && git pull && git checkout "$BRANCH" && git merge "$1"
	fi
}

# Checkout a PR by PR number (useful if someone created a PR from a fork)
# Note: 'git pr checkout $1' should work in place of this function but receives "x509: certificate signed by unknown authority" because of Walmart security settings
function gcpr() {
	git checkout master && git pull && git pull origin pull/"$1"/head:pr/"$1" && git checkout pr/"$1"
}

# Delete local git branches that are not present on the remote
function gclean() {
	git remote prune origin >/dev/null 2>&1

	MERGED_BRANCHES=$(git branch --merged master --no-color | cut -c 3- | grep -v '^[ *]*master$')
	ORPHAN_BRANCHES=$(grep gone <(git branch -v) | cut -d ' ' -f 3)
	BRANCHES_WITH_NO_REMOTE=$(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }')

	if [[ ! -z $MERGED_BRANCHES ]]; then
		ruler "Merged branches"
		echo $MERGED_BRANCHES
	fi

	if [[ ! -z $ORPHAN_BRANCHES ]]; then
		ruler "Orphan branches"
		echo $ORPHAN_BRANCHES
	fi

	if [[ ! -z $BRANCHES_WITH_NO_REMOTE ]]; then
		ruler "Branches with no remote"
		echo $BRANCHES_WITH_NO_REMOTE
	fi

	if [[ -z $MERGED_BRANCHES ]] && [[ -z $ORPHAN_BRANCHES ]] && [[ -z $BRANCHES_WITH_NO_REMOTE ]]
	then
		echo "Repo is already clean"
	else
		# Force delete of stubborn branches if -f is passed
		if [ "$1" = "-f" ]
		then
			echo
			read "DELETE?Force delete the listed branches? [y/N] "
			if [ "$DELETE" = "y" ]; then
				[[ ! -z "$MERGED_BRANCHES" ]] && { echo $MERGED_BRANCHES | xargs git branch -D; }
				[[ ! -z "$ORPHAN_BRANCHES" ]] && { echo $ORPHAN_BRANCHES | xargs git branch -D; }
				[[ ! -z "$BRANCHES_WITH_NO_REMOTE" ]] && { echo $BRANCHES_WITH_NO_REMOTE | xargs git branch -D; }
			else
				echo "Aborted"
			fi
		else
			echo
			read "DELETE?Delete the listed branches? [y/N] "
			if [ "$DELETE" = "y" ]; then
				[[ ! -z "$MERGED_BRANCHES" ]] && { echo $MERGED_BRANCHES | xargs git branch -d; }
				[[ ! -z "$ORPHAN_BRANCHES" ]] && { echo $ORPHAN_BRANCHES | xargs git branch -d; }
				[[ ! -z "$BRANCHES_WITH_NO_REMOTE" ]] && { echo $BRANCHES_WITH_NO_REMOTE | xargs git branch -d; }
			else
				echo "Aborted"
			fi
		fi
	fi
}

# Add all git changes with a commit message and push to remote
function g() {
	if [ -z "$1" ]
	then
		echo "No commit message supplied"
	else
		git add -A
		git commit -s -m "$1"
		git push -u
	fi
}

# Generate a .gitignore file using gitignore.io
function gi() {
	if [ -z "$1" ]
	then
		curl -L -s https://www.gitignore.io/api/linux,macos,windows
	else
		if [ "$1" = "list" ]
		then
			if [ -z "$2" ]
			then
				curl -L -s https://www.gitignore.io/api/list?format=lines
			else
				curl -L -s https://www.gitignore.io/api/list?format=lines | ack $2
			fi
		else
			curl -L -s https://www.gitignore.io/api/"$1"
		fi
	fi
}

# Find local git repositories that have unpushed commits or uncommitted files
function wip() {
	for repo in `find . -name .git -type d -prune`
	do
		# Use a subshell to avoid having to cd out of the directory)
		(
		cd $repo && cd ..

		if [[ ! -z $(git --no-pager diff HEAD) || ! -z $(git status --short) || ! -z $(git cherry -v 2>&1) || ! -z $(git --no-pager log --branches --not --remotes --no-walk --pretty=tformat:"%d%n") || ! -z $(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }') ]]
		then
			echo $repo

			# Make newlines the only split character
			IFS=$'\n'

			for line in `git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }'`
			do
				echo "  No remote: "$line
			done

			for line in `git --no-pager log --branches --not --remotes --no-walk --pretty=tformat:"%d%n"`
			do
				echo "  Unpushed/outdated: "$line
			done
		fi
		)
	done
}

####################
# Docker functions
####################

# Kill all running containers
function drydock() {
	docker kill "$(docker ps -a -q)" 2>/dev/null || true
}

# Kill and remove all containers
function scuttle() {
	docker kill "$(docker ps -a -q)" 2>/dev/null || true
	docker rm "$(docker ps -a -q)" 2>/dev/null || true
}

# Remove everything Docker-related
function sink() {
	docker system prune -a --volumes
}

####################
# General functions
####################

function ruler {
	printf '\n%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
	echo -e "$1"
	printf '%*s\n\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
}

function vf() {
	FILES=$(fzf)
	if [[ ! $FILES ]]; then
		return
	fi

	nvim "$FILES"
}

function tma() {
	tmux a -t "$1" -d
}

function imgsize() {
	magick identify "$1"
}

# Compare two files and print lines from the second file that are not included in the first file
function includes() {
	while read LINE
	do
		if ! grep -qr "\b$LINE\b" "$2"
		then
			echo $LINE # The line was not found
		fi
	done <$1
}

# Generate cellular automata wallpapers using gautomata
function cells() {
	if [ -z "$1" ]
	then
		echo "No iteration count supplied"
	else
		for i in {1..$1}
		do
			WIDTH=1920
			HEIGHT=800

			if [ -z "$2" ]
			then
				gautomata -w $WIDTH -h $HEIGHT -b -a random
			else
				gautomata -w $WIDTH -h $HEIGHT -b -a "$2"
			fi
		done

		echo "Scaling images"
		mogrify -scale 3840x1600+0+0 *.png
	fi
}

# Preview a file in the macOS Quick Look viewer
function q() {
	qlmanage -p "$@" >/dev/null 2>&1
}

# Copy the contents of a file to the clipboard
function copy() {
	pb < "$1"
}

# Run a LOVE project so you can see console output
function luv() {
	love "$(pwd)"
}

# Quickly search the current directory (and child directories) for files with filenames or contents that match the supplied search term
function search() {
	if [ "$1" = "-f" ]
	then
		find . -name "*$2*" | ack -i --passthru "$2"
	else
		find . -name "*$1*" | ack -i --passthru "$1"
		ack -i "$1"
	fi
}

# Find disk usage by directory
function usage() {
	sudo du -cha --max-depth=1 "$1" | sort -rh | grep -E "M|G"
}
