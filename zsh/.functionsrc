#!/usr/bin/env bash

# Putting this here until I move it into aks-ci
function poots() {
	ruler "Building Nanny"
	./aks-ci underlay-nanny-build
	ruler "Building Nanny Docker container"
	./aks-ci underlay-nanny-docker-build
	ruler "Pushing Nanny Docker container"
	./aks-ci underlay-nanny-docker-push
	ruler "Deleting existing helm deployment"
	h del --purge underlay-nanny
	ruler "Deploying to cluster"
	cat docs/helm-deploy.sh | envsubst | bash
	ruler "Sleeping for 20 seconds"
	sleep 20
	ruler "Getting logs"
	bananas
}

function bananas() {
	k logs -f -n infra $(k get po -n infra | grep 'Running\|Completed\|CrashLoopBackOff' | awk '{print $1}')
}

####################
# git functions
####################

# Compare the current branch to a supplied branch (or master if no branch is supplied) and view the diff (similar to creating a GitHub PR)
function gdpr() {
	if [[ -z $1 ]]
	then
		git diff master...$(git rev-parse --abbrev-ref HEAD)
	else
		git diff $1...$(git rev-parse --abbrev-ref HEAD)
	fi
}

# Quickly merge the current branch with a supplied branch (or master if no branch is supplied)
function gm() {
	BRANCH=$(git rev-parse --abbrev-ref HEAD)

	if [[ -z $1 ]]
	then
		git checkout master && git pull && git checkout $BRANCH && git merge master
	else
		git checkout $1 && git pull && git checkout $BRANCH && git merge $1
	fi
}

# Checkout a PR by PR number (useful if someone created a PR from a fork)
# Note: 'git pr checkout $1' should work in place of this function but receives "x509: certificate signed by unknown authority" because of Walmart security settings
function gcpr() {
	git checkout master && git pull && git pull origin pull/$1/head:pr/$1 && git checkout pr/$1
}

# Delete local git branches that are not present on the remote
function gclean() {
	git remote prune origin >/dev/null 2>&1

	MERGED_BRANCHES=$(git branch --merged master --no-color | cut -c 3- | grep -v '^[ *]*master$')
	ORPHAN_BRANCHES=$(grep gone <(git branch -v) | cut -d ' ' -f 3)
	BRANCHES_WITH_NO_REMOTE=$(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }')

	if [[ ! -z $MERGED_BRANCHES ]]; then
		echo "# Merged branches:"
		echo $MERGED_BRANCHES
	fi

	if [[ ! -z $ORPHAN_BRANCHES ]]; then
		echo "# Orphan branches:"
		echo $ORPHAN_BRANCHES
	fi

	if [[ ! -z $BRANCHES_WITH_NO_REMOTE ]]; then
		echo "# Branches with no remote:"
		echo $BRANCHES_WITH_NO_REMOTE
	fi

	if [[ -z $MERGED_BRANCHES ]] && [[ -z $ORPHAN_BRANCHES ]] && [[ -z $BRANCHES_WITH_NO_REMOTE ]]
	then
		echo "Repo is already clean"
	else
		# Force delete of stubborn branches if -f is passed
		if [ "$1" = "-f" ]
		then
			read "DELETE?Force delete the listed branches? [y/N] "
			if [ "$DELETE" = "y" ]; then
				echo $MERGED_BRANCHES | xargs git branch -D
				echo $ORPHAN_BRANCHES | xargs git branch -D
				echo $BRANCHES_WITH_NO_REMOTE | xargs git branch -D
			else
				echo "Aborted"
			fi
		else
			read "DELETE?Delete the listed branches? [y/N] "
			if [ "$DELETE" = "y" ]; then
				echo $MERGED_BRANCHES | xargs git branch -d
				echo $ORPHAN_BRANCHES | xargs git branch -d
				echo $BRANCHES_WITH_NO_REMOTE | xargs git branch -d
			else
				echo "Aborted"
			fi
		fi
	fi
}

# Add all git changes with a commit message (prepend the branch name to the commit message if the branch name contains a Jira card number) and push to remote
function gitt() {
	if [ -z "$1" ]
	then
		echo "No commit message supplied"
	else
		BRANCH="$(git rev-parse --abbrev-ref HEAD | awk 'match($0, /[A-Z]+-[[:digit:]]+/) { print substr($0, RSTART, RLENGTH) }')"

		git add -A

		if [ -z "$BRANCH" ]
		then
			git commit -s -m $1
		else
			git commit -s -m "$BRANCH $1"
		fi

		git push -u
	fi
}

# Generate a .gitignore file using gitignore.io
function gi() {
	if [ -z "$1" ]
	then
		curl -L -s https://www.gitignore.io/api/linux,macos,windows
	else
		if [ "$1" = "list" ]
		then
			if [ -z "$2" ]
			then
				curl -L -s https://www.gitignore.io/api/list?format=lines
			else
				curl -L -s https://www.gitignore.io/api/list?format=lines | ack $2
			fi
		else
			curl -L -s https://www.gitignore.io/api/"$1"
		fi
	fi
}

# Find local git repositories that have unpushed commits or uncommitted files
function wip() {
	for repo in `find . -name .git -type d -prune`
	do
		# Use a subshell to avoid having to cd out of the directory)
		(
		cd $repo && cd ..

		if [[ ! -z $(git --no-pager diff HEAD) || ! -z $(git status --short) || ! -z $(git cherry -v 2>&1) || ! -z $(git --no-pager log --branches --not --remotes --no-walk --pretty=tformat:"%d%n") || ! -z $(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }') ]]
		then
			echo $repo

			# Make newlines the only split character
			IFS=$'\n'

			for line in `git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }'`
			do
				echo "  No remote: "$line
			done

			for line in `git --no-pager log --branches --not --remotes --no-walk --pretty=tformat:"%d%n"`
			do
				echo "  Unpushed/outdated: "$line
			done
		fi
		)
	done
}

####################
# Arduboy functions
# Note: These functions were created and used during visual asset development of Crates (https://github.com/compycore/crates)
####################

function ardbitmap() {
	# Deal with GIFs
	if [[ $1 == *.gif ]]
	then
		# The image we're currently on
		COUNTER=0

		# Create a directory to put the frames into
		mkdir ardbitmap
		# Rip the GIF into frames
		convert $1 ardbitmap/frame%03d.png

		# Loop through the frames
		for IMAGE in ardbitmap/*
		do
			# Run the compressor on the single frame
			java -jar ~/.ardbitmap/compressor.jar $IMAGE >> $2

			# Number the frame in the output file using the counter
			sed -i '' -e 's/OUT\[\]/OUT_'$COUNTER'\[\]/g' $2

			# Add a couple newlines to the output file
			echo >> $2
			echo >> $2

			# Increment the counter
			COUNTER=$((COUNTER+1))

			# Preview the image if we passed a third argument
			if [[ $3 ]]
			then
				java -jar ~/.ardbitmap/compressor.jar $IMAGE -v
			fi
		done

		# Cleanup
		rm -rf ardbitmap
	else
		# Run the compressor on the single frame
		java -jar ~/.ardbitmap/compressor.jar $1 >> $2

		# Preview the image if we passed a third argument
		if [[ $3 ]]
		then
			java -jar ~/.ardbitmap/compressor.jar $1 -v
		fi
	fi
}

function maskify() {
	if [[ $1 == *.gif ]]
	then
		# Get just the filename
		FILENAME="${1%.*}"

		# Make directories for organization
		mkdir -p maskify/black
		mkdir -p maskify/white

		# Split the animation
		convert $1 maskify/frame%03d.png

		# Make the masks
		cd maskify/black
		convert ../*.png -transparent white -opaque black -fill white -set filename:f '%t-mask-black.%e' +adjoin '%[filename:f]'
		# Make an animation
		convert -delay 10 -dispose previous -loop 0 *.png ../../$FILENAME-mask-black.gif
		cd ../..

		cd maskify/white
		convert ../*.png -transparent black -set filename:f '%t-mask-white.%e' +adjoin '%[filename:f]'
		# Make an animation
		convert -delay 10 -dispose previous -loop 0 *.png ../../$FILENAME-mask-white.gif
		cd ../..

		# Cleanup
		rm -rf maskify
	else
		convert $1 -transparent white -opaque black -fill white -set filename:f '%t-mask-black.%e' +adjoin '%[filename:f]'
		convert $1 -transparent black -set filename:f '%t-mask-white.%e' +adjoin '%[filename:f]'
	fi
}

function bitify() {
	if [[ -z $1 || -z $2 || -z $3 ]]
	then
		echo "One or more arguments are missing"
	elif (( $3 % 8 != 0 ))
	then
		echo "Image height must be a multiple of 8"
	else
		# Make an animation
		convert -monochrome -scale 500% -delay 10 -dispose previous -loop 0 *.png ../$1.gif
		# Make the individual frames
		convert *.png -gravity center -crop $2x$3+0+0 -set filename:f '%t-cropped.%e' +adjoin '%[filename:f]'
		# Make an opacity mask sprite sheet
		convert *-cropped.png -append -fill white -colorize 100% -background black -alpha remove mask.png
		# Combine and dither frames into a sprite sheet
		convert *-cropped.png -append -monochrome sheet.png
		# Copy opacity into the dithered sprite sheet
		convert sheet.png mask.png -alpha off -compose CopyOpacity -composite ../$1_$2x$3.png
		# Clean up
		rm *-cropped.png
		rm mask.png
		rm sheet.png
	fi
}

function gifify() {
	if [[ -z $1 || -z $2 || -z $3 ]]
	then
		echo "One or more arguments are missing"
	elif (( $3 % 8 != 0 ))
	then
		echo "Image height must be a multiple of 8"
	else
		for IMAGE in *
		do
			# Get just the filename (no extension)
			FILENAME="${IMAGE%.*}"
			# Make the individual frames
			convert $IMAGE -gravity center -crop $2x$3+0+0 +repage -set filename:f '%t-cropped.%e' +adjoin '%[filename:f]'
			# Make an opacity mask sprite sheet
			convert $FILENAME-cropped.png -fill white -colorize 100% -background black -alpha remove -set filename:f '%t-mask.%e' +adjoin '%[filename:f]'
			# Make the cropped frames monochrome
			convert $FILENAME-cropped.png -monochrome -set filename:f '%t-monochrome.%e' +adjoin '%[filename:f]'
			# Copy opacity into the dithered sprite sheet
			convert $FILENAME-cropped-monochrome.png $FILENAME-cropped-mask.png -alpha off -compose CopyOpacity -composite $FILENAME-final.png
		done

		# Make an animation
		convert -delay 10 -dispose previous -loop 0 *-final.png ../$1.gif

		# Clean up
		rm *-cropped.png
		rm *-cropped-monochrome.png
		rm *-cropped-mask.png
		rm *-final.png
	fi
}

####################
# Docker functions
####################

# Kill all running containers
function drydock() {
	docker kill $(docker ps -a -q) 2>/dev/null || true
}

# Kill and remove all containers
function scuttle() {
	docker kill $(docker ps -a -q) 2>/dev/null || true
	docker rm $(docker ps -a -q) 2>/dev/null || true
}

# Remove everything Docker-related
function sink() {
	docker system prune -a --volumes
}

####################
# Work functions
####################

# This function mimics `eval $(aksiknife dev-setup)` but uses pass to circumvent the need for an AME card
azlogin() {
	export AZURE_TENANT_ID=$(pass show $1/$2/azure-tenant-id)
	export AZURE_CLIENT_ID=$(pass show $1/$2/azure-client-id)
	export AZURE_CLIENT_SECRET=$(pass show $1/$2/azure-client-secret)

	az login --tenant $AZURE_TENANT_ID --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET
}

####################
# General functions
####################

function ruler {
	printf '\n%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
	echo -e "$1"
	printf '%*s\n\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
}

function vf() {
	FILES=$(fzf)
	if [[ ! $FILES ]]; then
		return
	fi

	nvim $FILES
}

function tma() {
	tmux a -t $1 -d
}

function fimg() {
	curl $1 --silent | sed -n 's/.*href="\([^"]*\).*/\1/p' | ack 'jpeg|jpg|png' | ack --passthru 'shopify'
}

function imgsize() {
	magick identify $1
}

# Compare two files and print lines from the second file that are not included in the first file
function includes() {
	while read LINE
	do
		if ! grep -qr "\b$LINE\b" "$2"
		then
			echo $LINE # The line was not found
		fi
	done <$1
}

# Generate cellular automata wallpapers using gautomata
function cells() {
	if [ -z $1 ]
	then
		echo "No iteration count supplied"
	else
		for i in {1..$1}
		do
			WIDTH=1920
			HEIGHT=800

			if [ -z $2 ]
			then
				gautomata -w $WIDTH -h $HEIGHT -b -a random
			else
				gautomata -w $WIDTH -h $HEIGHT -b -a $2
			fi
		done

		echo "Scaling images"
		mogrify -scale 3840x1600+0+0 *.png
	fi
}

# Preview a file in the macOS Quick Look viewer
function q() {
	qlmanage -p "$@" >/dev/null 2>&1
}

# CLI file explorer with cd on close functionality (triggered via Control + G)
function e() {
	nnn "$@"

	if [ -f $NNN_TMPFILE ]; then
		. $NNN_TMPFILE
		rm $NNN_TMPFILE
	fi
}

# Copy the contents of a file to the clipboard
function copy() {
	cat $1 | pb
}

# Run a LOVE project so you can see console output
function luv() {
	love $(pwd)
}

# Quickly search the current directory (and child directories) for files with filenames or contents that match the supplied search term
function search() {
	if [ $1 = "-f" ]
	then
		find . -name "*$2*" | ack -i --passthru "$2"
	else
		find . -name "*$1*" | ack -i --passthru "$1"
		ack -i "$1"
	fi
}

# Find disk usage by directory
function usage() {
	sudo du -cha --max-depth=1 "$1" | sort -rh | grep -E "M|G"
}
