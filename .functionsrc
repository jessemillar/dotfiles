#!/usr/bin/env bash

function q() {
	qlmanage -p "$@" >/dev/null 2>&1
}

function search() {
	if [ $1 = "-f" ]
	then
		find . -name "*$2*" | ack --passthru "$2"
	else
		find . -name "*$1*" | ack --passthru "$1"
		ack "$1"
	fi
}

function qr() {
	qrencode -s 10 -o - $1 | open -f -a preview
}

function mssh() {
	for HOST in $(cat $2)
	do
		ssh -o StrictHostKeyChecking=no "$1@$HOST" "$3" >"output.$HOST" 2>"output.$HOST.err" &
	done
	wait
}

function msshp() {
	read -s "PASS?Password: "

	for HOST in $(cat $2)
	do
		sshpass -p "$PASS" ssh -o StrictHostKeyChecking=no "$1@$HOST" "$3" >"output.$HOST" 2>"output.$HOST.err" &
	done
	wait
}

function crup() {
	brew cask reinstall $(brew cask outdated) || true
	brew cask cleanup
}

function drydock() {
	docker kill $(docker ps -a -q) 2>/dev/null || true
}

function scuttle() {
	docker kill $(docker ps -a -q) 2>/dev/null || true
	docker rm $(docker ps -a -q) 2>/dev/null || true
}

function sink() {
	docker rmi $(docker images -q) 2>/dev/null || true
}

function gitt() {
	if [ -z "$1" ]
	then
		echo "No commit message supplied"
	else
		BRANCH="$(git rev-parse --abbrev-ref HEAD | awk 'match($0, /[A-Z]+-[[:digit:]]+/) { print substr($0, RSTART, RLENGTH) }')"

		git add -A

		if [ -z "$BRANCH" ]
		then
			git commit -m $1
		else
			git commit -m "$BRANCH $1"
		fi

		git push
	fi
}

function gi() {
	if [ -z "$1" ]
	then
		curl -L -s https://www.gitignore.io/api/linux,macos,windows | sed '1d'
	else
		if [ "$1" == "list" ]
		then
			if [ -z "$2" ]
			then
				curl -L -s https://www.gitignore.io/api/list?format=lines
			else
				curl -L -s https://www.gitignore.io/api/list?format=lines | ack $2
			fi
		else
			curl -L -s https://www.gitignore.io/api/"$1" | sed '1d'
		fi
	fi
}

function includes() {
	while read LINE
	do
		if ! grep -qr "\b$LINE\b" "$2"
		then
			echo $LINE # The line was not found
		fi
	done <$1
}

function cells() {
	if [ -z $1 ]
	then
		echo "No iteration count supplied"
	else
		for i in {1..$1}
		do
			WIDTH=960
			HEIGHT=600

			if [ -z $2 ]
			then
				gautomata -w $WIDTH -h $HEIGHT -b -a random
			else
				gautomata -w $WIDTH -h $HEIGHT -b -a $2
			fi
		done

		echo "Scaling images"
		mogrify -scale 5760x3600+0+0 *.png
	fi
}

function bitify() {
	if [[ -z $1 || -z $2 || -z $3 ]]
	then
		echo "One or more arguments are missing"
	elif (( $3 % 8 != 0 ))
	then
		echo "Image height must be a multiple of 8"
	else
		# Make an animation
		convert -monochrome -scale 500% -delay 10 -dispose previous -loop 0 *.png ../$1.gif
		# Make the individual frames
		convert *.png -gravity center -crop $2x$3+0+0 -set filename:f '%t-cropped.%e' +adjoin '%[filename:f]'
		# Make an opacity mask sprite sheet
		convert *-cropped.png -append -fill white -colorize 100% -background black -alpha remove mask.png
		# Combine and dither frames into a sprite sheet
		convert *-cropped.png -append -monochrome sheet.png
		# Copy opacity into the dithered sprite sheet
		convert sheet.png mask.png -alpha off -compose CopyOpacity -composite ../$1_$2x$3.png
		# Clean up
		rm *-cropped.png
		rm mask.png
		rm sheet.png
	fi
}

# Used for taking notes from the command line
function n() {
	local fpath=$HOME/Desktop/notes.md

	if [ "$1" == "v" ]; then
		nvim + $fpath
	elif [ "$1" == "date" ]; then
		echo '' >> $fpath
		echo '# '`date +"%m-%d-%Y-%T"` >> $fpath
		echo '---------------------' >> $fpath
	elif [ "$1" == "" ]; then
		less +G $fpath
	else
		echo '' >> $fpath
		echo $@ >> $fpath
	fi
}

# Make a reminder in Reminders.app
# TODO Implement relative date parsing (e.g. "in 5 minutes", "at 5pm", "on Tuesday", and "on Tuesday at 3pm") and accept only one parameter
function remind() {
	if [[ -z $1 || -z $2 || -z $3 ]]
	then
		echo "One or more arguments are missing"
	else
		osascript - <<EOD
			set stringedAll to date ("$2" & " " & "$3")
			tell application "Reminders" to tell list "Reminders" to make new reminder with properties {name:"$1", remind me date:stringedAll, due date:stringedAll}
EOD
	fi
}
