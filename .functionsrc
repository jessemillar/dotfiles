#!/usr/bin/env bash

function f() {
	nnn "$@"

	if [ -f $NNN_TMPFILE ]; then
		. $NNN_TMPFILE
		rm $NNN_TMPFILE
	fi
}

function brup() {
	brew -v update &&\
	brew -v upgrade &&\
	brew -v cleanup &&\
	brew -v doctor &&\

	brew -v cask upgrade --greedy &&\

	pip3 install pip --upgrade &&\
	pip3 install neovim --upgrade &&\

	nvim +GoUpdateBinaries +PlugUpdate +PlugUpgrade +qall &&\

	echo "brup() finished"
}

function luv() {
	love $(pwd)
}

function gdm() {
	git diff master...$(git rev-parse --abbrev-ref HEAD)
}

function gm() {
	BRANCH=$(git rev-parse --abbrev-ref HEAD)

	if [[ -z $1 ]]
	then
		git checkout master && git pull && git checkout $BRANCH && git merge master
	else
		git checkout $1 && git pull && git checkout $BRANCH && git merge $1
	fi
}

function gcpr() {
	git checkout master && git pull && git pull origin pull/$1/head:pr/$1 && git checkout pr/$1
}

function gclean() {
	git remote prune origin >/dev/null 2>&1

	if [ "$1" == "-f" ]
	then
		git branch -vv | grep 'origin/.*: gone]' | awk '{print $1}' | xargs git branch -D
	else
		git branch -vv | grep 'origin/.*: gone]' | awk '{print $1}' | xargs git branch -d
	fi
}

# Find local git repositories that have unpushed commits or uncommitted files
function wip() {
	for repo in `find . -name .git -type d -prune`
	do
		# Use a subshell to avoid having to cd out of the directory)
		(
		cd $repo && cd ..

		if [[ ! -z $(git --no-pager diff HEAD) || ! -z $(git status --short) || ! -z $(git cherry -v 2>&1) || ! -z $(git --no-pager log --branches --not --remotes --no-walk --pretty=tformat:"%d%n") || ! -z $(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }') ]]
		then
			echo $repo

			# Make newlines the only split character
			IFS=$'\n'

			for line in `git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print $1 }'`
			do
				echo "  No remote: "$line
			done

			for line in `git --no-pager log --branches --not --remotes --no-walk --pretty=tformat:"%d%n"`
			do
				echo "  Unpushed/outdated: "$line
			done
		fi
		)
	done
}

function search() {
	if [ $1 = "-f" ]
	then
		find . -name "*$2*" | ack -i --passthru "$2"
	else
		find . -name "*$1*" | ack -i --passthru "$1"
		ack -i "$1"
	fi
}

function ardbitmap() {
	# Deal with GIFs
	if [[ $1 == *.gif ]]
	then
		# The image we're currently on
		COUNTER=0

		# Create a directory to put the frames into
		mkdir ardbitmap
		# Rip the GIF into frames
		convert $1 ardbitmap/frame%03d.png

		# Loop through the frames
		for IMAGE in ardbitmap/*
		do
			# Run the compressor on the single frame
			java -jar ~/.ardbitmap/compressor.jar $IMAGE >> $2

			# Number the frame in the output file using the counter
			sed -i '' -e 's/OUT\[\]/OUT_'$COUNTER'\[\]/g' $2

			# Add a couple newlines to the output file
			echo >> $2
			echo >> $2

			# Increment the counter
			COUNTER=$((COUNTER+1))

			# Preview the image if we passed a third argument
			if [[ $3 ]]
			then
				java -jar ~/.ardbitmap/compressor.jar $IMAGE -v
			fi
		done

		# Cleanup
		rm -rf ardbitmap
	else
		# Run the compressor on the single frame
		java -jar ~/.ardbitmap/compressor.jar $1 >> $2

		# Preview the image if we passed a third argument
		if [[ $3 ]]
		then
			java -jar ~/.ardbitmap/compressor.jar $1 -v
		fi
	fi
}

function maskify() {
	if [[ $1 == *.gif ]]
	then
		# Get just the filename
		FILENAME="${1%.*}"

		# Make directories for organization
		mkdir -p maskify/black
		mkdir -p maskify/white

		# Split the animation
		convert $1 maskify/frame%03d.png

		# Make the masks
		cd maskify/black
		convert ../*.png -transparent white -opaque black -fill white -set filename:f '%t-mask-black.%e' +adjoin '%[filename:f]'
		# Make an animation
		convert -delay 10 -dispose previous -loop 0 *.png ../../$FILENAME-mask-black.gif
		cd ../..

		cd maskify/white
		convert ../*.png -transparent black -set filename:f '%t-mask-white.%e' +adjoin '%[filename:f]'
		# Make an animation
		convert -delay 10 -dispose previous -loop 0 *.png ../../$FILENAME-mask-white.gif
		cd ../..

		# Cleanup
		rm -rf maskify
	else
		convert $1 -transparent white -opaque black -fill white -set filename:f '%t-mask-black.%e' +adjoin '%[filename:f]'
		convert $1 -transparent black -set filename:f '%t-mask-white.%e' +adjoin '%[filename:f]'
	fi
}

function bitify() {
	if [[ -z $1 || -z $2 || -z $3 ]]
	then
		echo "One or more arguments are missing"
	elif (( $3 % 8 != 0 ))
	then
		echo "Image height must be a multiple of 8"
	else
		# Make an animation
		convert -monochrome -scale 500% -delay 10 -dispose previous -loop 0 *.png ../$1.gif
		# Make the individual frames
		convert *.png -gravity center -crop $2x$3+0+0 -set filename:f '%t-cropped.%e' +adjoin '%[filename:f]'
		# Make an opacity mask sprite sheet
		convert *-cropped.png -append -fill white -colorize 100% -background black -alpha remove mask.png
		# Combine and dither frames into a sprite sheet
		convert *-cropped.png -append -monochrome sheet.png
		# Copy opacity into the dithered sprite sheet
		convert sheet.png mask.png -alpha off -compose CopyOpacity -composite ../$1_$2x$3.png
		# Clean up
		rm *-cropped.png
		rm mask.png
		rm sheet.png
	fi
}

function gifify() {
	if [[ -z $1 || -z $2 || -z $3 ]]
	then
		echo "One or more arguments are missing"
	elif (( $3 % 8 != 0 ))
	then
		echo "Image height must be a multiple of 8"
	else
		for IMAGE in *
		do
			# Get just the filename (no extension)
			FILENAME="${IMAGE%.*}"
			# Make the individual frames
			convert $IMAGE -gravity center -crop $2x$3+0+0 +repage -set filename:f '%t-cropped.%e' +adjoin '%[filename:f]'
			# Make an opacity mask sprite sheet
			convert $FILENAME-cropped.png -fill white -colorize 100% -background black -alpha remove -set filename:f '%t-mask.%e' +adjoin '%[filename:f]'
			# Make the cropped frames monochrome
			convert $FILENAME-cropped.png -monochrome -set filename:f '%t-monochrome.%e' +adjoin '%[filename:f]'
			# Copy opacity into the dithered sprite sheet
			convert $FILENAME-cropped-monochrome.png $FILENAME-cropped-mask.png -alpha off -compose CopyOpacity -composite $FILENAME-final.png
		done

		# Make an animation
		convert -delay 10 -dispose previous -loop 0 *-final.png ../$1.gif

		# Clean up
		rm *-cropped.png
		rm *-cropped-monochrome.png
		rm *-cropped-mask.png
		rm *-final.png
	fi
}

function mssh() {
	for HOST in $(cat $2)
	do
		ssh -o StrictHostKeyChecking=no "$1@$HOST" "$3" >"output.$HOST.txt" 2>"output.$HOST.err.txt" &
	done
	wait
}

function msshp() {
	read -s "PASS?Password: "

	for HOST in $(cat $2)
	do
		sshpass -p "$PASS" ssh -o StrictHostKeyChecking=no "$1@$HOST" "$3" >"output.$HOST.txt" 2>"output.$HOST.err.txt" &
	done
	wait
}

function crup() {
	brew cask reinstall $(brew cask outdated) || true
	brew cask cleanup
}

function drydock() {
	docker kill $(docker ps -a -q) 2>/dev/null || true
}

function scuttle() {
	docker kill $(docker ps -a -q) 2>/dev/null || true
	docker rm $(docker ps -a -q) 2>/dev/null || true
}

function sink() {
	docker rmi $(docker images -q) 2>/dev/null || true
}

function gitt() {
	if [ -z "$1" ]
	then
		echo "No commit message supplied"
	else
		BRANCH="$(git rev-parse --abbrev-ref HEAD | awk 'match($0, /[A-Z]+-[[:digit:]]+/) { print substr($0, RSTART, RLENGTH) }')"

		git add -A

		if [ -z "$BRANCH" ]
		then
			git commit -m $1
		else
			git commit -m "$BRANCH $1"
		fi

		git push
	fi
}

function gi() {
	if [ -z "$1" ]
	then
		curl -L -s https://www.gitignore.io/api/linux,macos,windows
	else
		if [ "$1" = "list" ]
		then
			if [ -z "$2" ]
			then
				curl -L -s https://www.gitignore.io/api/list?format=lines
			else
				curl -L -s https://www.gitignore.io/api/list?format=lines | ack $2
			fi
		else
			curl -L -s https://www.gitignore.io/api/"$1"
		fi
	fi
}

function includes() {
	while read LINE
	do
		if ! grep -qr "\b$LINE\b" "$2"
		then
			echo $LINE # The line was not found
		fi
	done <$1
}

function cells() {
	if [ -z $1 ]
	then
		echo "No iteration count supplied"
	else
		for i in {1..$1}
		do
			WIDTH=960
			HEIGHT=600

			if [ -z $2 ]
			then
				gautomata -w $WIDTH -h $HEIGHT -b -a random
			else
				gautomata -w $WIDTH -h $HEIGHT -b -a $2
			fi
		done

		echo "Scaling images"
		mogrify -scale 5760x3600+0+0 *.png
	fi
}

function q() {
	qlmanage -p "$@" >/dev/null 2>&1
}

function twoot() {
	madonctl toot $1
	twty $1
}

# Used for taking notes from the command line
function n() {
	local fpath=$HOME/Desktop/notes.md

	if [ "$1" = "v" ]; then
		nvim + $fpath
	elif [ "$1" = "date" ]; then
		echo '' >> $fpath
		echo '# '`date +"%m-%d-%Y-%T"` >> $fpath
		echo '---------------------' >> $fpath
	elif [ "$1" = "" ]; then
		less +G $fpath
	else
		echo '' >> $fpath
		echo $@ >> $fpath
	fi
}


# ASCII art
function labs() {
	echo $fg[cyan] "
       :########:
       ###' ####
      :### .###:
      ###' ####
     :### .###:
    .###' ####
    #### .##############
   :###' #############:
   ####.,,,,,,,,,,####
   :################:
    '*:############
           ######:
          :#####
          ####:
         :###
         ##:
         %
"
}

function sombra() {
	echo $fg[magenta] "
                      :PB@Bk:
                  ,jB@@B@B@B@BBL.
               7G@B@B@BMMMMMB@B@B@Nr
           :kB@B@@@MMOMOMOMOMMMM@B@B@B1,
       :5@B@B@B@BBMMOMOMOMOMOMOMM@@@B@B@BBu.
    70@@@B@B@B@BXBBOMOMOMOMOMOMMBMPB@B@B@B@B@Nr
  G@@@BJ iB@B@@  OBMOMOMOMOMOMOM@2  B@B@B. EB@B@S
  @@BM@GJBU.  iSuB@OMOMOMOMOMOMM@OU1:  .kBLM@M@B@
  B@MMB@B       7@BBMMOMOMOMOMOBB@:       B@BMM@B
  @@@B@B         7@@@MMOMOMOMM@B@:         @@B@B@
  @@OLB.          BNB@MMOMOMM@BEB          rBjM@B
  @@  @           M  OBOMOMM@q  M          .@  @@
  @@OvB           B:u@MMOMOMMBJiB          .BvM@B
  @B@B@J         0@B@MMOMOMOMB@B@u         q@@@B@
  B@MBB@v       G@@BMMMMMMMMMMMBB@5       F@BMM@B
  @BBM@BPNi   LMEB@OMMMM@B@MMOMM@BZM7   rEqB@MBB@
  B@@@BM  B@B@B  qBMOMB@B@B@BMOMBL  B@B@B  @B@B@M
   J@@@@PB@B@B@B7G@OMBB.   ,@MMM@qLB@B@@@BqB@BBv
      iGB@,i0@M@B@MMO@E  :  M@OMM@@@B@Pii@@N:
         .   B@M@B@MMM@B@B@B@MMM@@@M@B
             @B@B.i@MBB@B@B@@BM@::B@B@
             B@@@ .B@B.:@B@ :B@B  @B@O
               :0 r@B@  B@@ .@B@: P:
                   vMB :@B@ :BO7
                       ,B@B
"
}

function compycore() {
	echo $fg[cyan] "
               ,*##*                     ###*,
             ,*####                        ######,
            *######                         #######
           *#######*     ,,**##########**,,,########
           ##########**###*'             '*#########
           ############                      ######'
            ##########*                        ####
             ########'                          ##,,,,,,,,
             #'###*'                        *###*,#########
           ,##'           .*#####*  ,*####*,#''''######''##
 ,,,,,*#######*         *######### ######### ,##*  #####*'
###############        ###*''       #########'##'  '#'
'#, ###########         .#    ,###,  #########      ##
  '##,,,,,  '''              #    *   ###'    #     ##
     '#######,                          *##..#      ##
            ##                                 #,  ##'
             ##                               ,## *##
              #*                     #,    ,*#' *,##
               ##*                   ### #'' ,####'
                '##*,                       ,######*
                  '####*,               ,*###' ## #
                      '######*,,,,*######'
                            '######'
"
}
