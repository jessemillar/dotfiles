#!/usr/bin/env bash

function q() {
	qlmanage -p "$@" >/dev/null 2>&1
}

function search() {
	if [ $1 = "-f" ]
	then
		find . -name "*$2*" | ack --passthru "$2"
	else
		find . -name "*$1*" | ack --passthru "$1"
		ack "$1"
	fi
}

function qr() {
	qrencode -s 10 -o - $1 | open -f -a preview
}

function mssh() {
	for HOST in $(cat $2)
	do
		ssh -o StrictHostKeyChecking=no "$1@$HOST" "$3" >"output.$HOST" 2>"output.$HOST.err" &
	done
	wait
}

function msshp() {
	read -s "PASS?Password: "

	for HOST in $(cat $2)
	do
		sshpass -p "$PASS" ssh -o StrictHostKeyChecking=no "$1@$HOST" "$3" >"output.$HOST" 2>"output.$HOST.err" &
	done
	wait
}

function crup() {
	brew cask reinstall $(brew cask outdated) || true
	brew cask cleanup
}

function drydock() {
	docker kill $(docker ps -a -q) 2>/dev/null || true
}

function scuttle() {
	docker kill $(docker ps -a -q) 2>/dev/null || true
	docker rm $(docker ps -a -q) 2>/dev/null || true
}

function sink() {
	docker rmi $(docker images -q) 2>/dev/null || true
}

function gitt() {
	if [ -z "$1" ]
	then
		echo "No commit message supplied"
	else
		BRANCH="$(git rev-parse --abbrev-ref HEAD | awk 'match($0, /[A-Z]+-[[:digit:]]+/) { print substr($0, RSTART, RLENGTH) }')"

		git add -A

		if [ -z "$BRANCH" ]
		then
			git commit -m $1
		else
			git commit -m "$BRANCH $1"
		fi

		git push
	fi
}

function gi() {
	if [ -z "$1" ]
	then
		curl -L -s https://www.gitignore.io/api/linux,macos,windows | sed '1d'
	else
		if [ "$1" = "list" ]
		then
			if [ -z "$2" ]
			then
				curl -L -s https://www.gitignore.io/api/list?format=lines
			else
				curl -L -s https://www.gitignore.io/api/list?format=lines | ack $2
			fi
		else
			curl -L -s https://www.gitignore.io/api/"$1" | sed '1d'
		fi
	fi
}

function includes() {
	while read LINE
	do
		if ! grep -qr "\b$LINE\b" "$2"
		then
			echo $LINE # The line was not found
		fi
	done <$1
}

function cells() {
	if [ -z $1 ]
	then
		echo "No iteration count supplied"
	else
		for i in {1..$1}
		do
			WIDTH=960
			HEIGHT=600

			if [ -z $2 ]
			then
				gautomata -w $WIDTH -h $HEIGHT -b -a random
			else
				gautomata -w $WIDTH -h $HEIGHT -b -a $2
			fi
		done

		echo "Scaling images"
		mogrify -scale 5760x3600+0+0 *.png
	fi
}

function bitify() {
	if [[ -z $1 || -z $2 || -z $3 ]]
	then
		echo "One or more arguments are missing"
	elif (( $3 % 8 != 0 ))
	then
		echo "Image height must be a multiple of 8"
	else
		# Make an animation
		convert -monochrome -scale 500% -delay 10 -dispose previous -loop 0 *.png ../$1.gif
		# Make the individual frames
		convert *.png -gravity center -crop $2x$3+0+0 -set filename:f '%t-cropped.%e' +adjoin '%[filename:f]'
		# Make an opacity mask sprite sheet
		convert *-cropped.png -append -fill white -colorize 100% -background black -alpha remove mask.png
		# Combine and dither frames into a sprite sheet
		convert *-cropped.png -append -monochrome sheet.png
		# Copy opacity into the dithered sprite sheet
		convert sheet.png mask.png -alpha off -compose CopyOpacity -composite ../$1_$2x$3.png
		# Clean up
		rm *-cropped.png
		rm mask.png
		rm sheet.png
	fi
}

# Used for taking notes from the command line
function n() {
	local fpath=$HOME/Desktop/notes.md

	if [ "$1" = "v" ]; then
		nvim + $fpath
	elif [ "$1" = "date" ]; then
		echo '' >> $fpath
		echo '# '`date +"%m-%d-%Y-%T"` >> $fpath
		echo '---------------------' >> $fpath
	elif [ "$1" = "" ]; then
		less +G $fpath
	else
		echo '' >> $fpath
		echo $@ >> $fpath
	fi
}

# Make a reminder in Reminders.app
# TODO Implement relative date parsing (e.g. "in 5 minutes", "at 5pm", "on Tuesday", and "on Tuesday at 3pm") and accept only one parameter
function remind() {
	if [[ -z $1 || -z $2 || -z $3 ]]
	then
		echo "One or more arguments are missing"
	else
		# Get the message without the time fields
		# TODO Make this cleaner
		CONTENT="$(echo $1 | awk '{ $1=""; $2=""; $3=""; print}')"
		# This will be "in", "at", or "on"
		KEYWORD="$(echo $1 | awk '{print $1;}')"

		if [ $KEYWORD = "in" ]
		then
			# This will be an integer representing how far in the future in minutes, hours, etc. we want
			AMOUNT="$(echo $1 | awk '{print $2;}')"
			# This will be minutes, hours, etc.
			PERIOD="$(echo $1 | awk '{print $3;}')"
			echo $PERIOD

			if [[ $PERIOD = "minutes" || $PERIOD = "minute" || $PERIOD = "mins" || $PERIOD = "min" ]]
			then
				PERIOD="M"
			elif [[ $PERIOD = "hours" || $PERIOD = "hour" || $PERIOD = "hrs" || $PERIOD = "hr" ]]
			then
				PERIOD="H"
			elif [[ $PERIOD = "days" || $PERIOD = "day" || $PERIOD = "ds" || $PERIOD = "d" ]]
			then
				PERIOD="d"
			elif [[ $PERIOD = "weeks" || $PERIOD = "week" || $PERIOD = "wks" || $PERIOD = "wk" ]]
			then
				PERIOD="w"
			elif [[ $PERIOD = "months" || $PERIOD = "month" || $PERIOD = "m" ]]
			then
				PERIOD="m"
			elif [[ $PERIOD = "years" || $PERIOD = "year" || $PERIOD = "yrs" || $PERIOD = "yr" || $PERIOD = "y" ]]
			then
				PERIOD="y"
			fi

			DATE="$(date -v +$AMOUNT$PERIOD)"
			echo $(date)
			echo $DATE
		fi

		osascript - <<EOD
			set stringDate to date ("$DATE")
			tell application "Reminders" to tell list "Reminders" to make new reminder with properties {name:"$CONTENT", remind me date:stringDate, due date:stringDate}
EOD
	fi
}
